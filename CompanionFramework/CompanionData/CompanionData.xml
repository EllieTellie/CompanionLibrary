<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CompanionData</name>
    </assembly>
    <members>
        <member name="M:Companion.Data.StringExtensions.Trim(System.String[])">
            <summary>
            Trim all the whitespace from the strings in this array.
            </summary>
            <param name="arr">Array</param>
        </member>
        <member name="F:Companion.Data.SelectionEntry.parent">
            <summary>
            Parent selection if available.
            </summary>
        </member>
        <member name="F:Companion.Data.Selection.parent">
            <summary>
            Parent selection if available.
            </summary>
        </member>
        <member name="F:Companion.Data.XmlData.comment">
            <summary>
            Optional comment for data.
            </summary>
        </member>
        <member name="F:Companion.Data.XmlData.xmlns">
            <summary>
            Optional xml schema.
            </summary>
        </member>
        <member name="F:Companion.Data.XmlData.fields">
            <summary>
            List of xml lists containing all the nodes after parsing.
            </summary>
        </member>
        <member name="M:Companion.Data.XmlData.InitFields">
            <summary>
            Init the fields usually lists to a new empty list. By default does nothing.
            </summary>
        </member>
        <member name="T:Companion.Data.GameSystemGroup">
            <summary>
            Group of catalogues and systems used in a roster. Mostly for roster detection speed.
            </summary>
        </member>
        <member name="E:Companion.Data.RosterReader.OnRosterParsed">
            <summary>
            Dispatched on the main unity thread. Source is roster. EventArgs is null.
            </summary>
        </member>
        <member name="T:Companion.Data.WordReader">
            <summary>
            Simple reader that reads words. 
            </summary>
        </member>
        <member name="E:Companion.Data.System.Update.CoreUpdateProcess.LoadingComplete">
            <summary>
            Fired when the process completed.
            </summary>
        </member>
        <member name="E:Companion.Data.System.Update.CoreUpdateProcess.LoadingAborted">
            <summary>
            Fired when the process is aborted.
            </summary>
        </member>
        <member name="M:Companion.Data.System.Update.CoreUpdateProcess.Execute(Companion.Data.System.Update.UpdateStateData)">
            <summary>
            Execute the loading process and passes any state through.
            </summary>
            <param name="state">current state</param>
        </member>
        <member name="M:Companion.Data.System.Update.CoreUpdateProcess.GetState">
            <summary>
            The update state this process handles.
            </summary>
            <returns>update state</returns>
        </member>
        <member name="M:Companion.Data.System.Update.CoreUpdateProcess.Abort">
            <summary>
            Aborts the process. Fires the abort event.
            </summary>
        </member>
        <member name="M:Companion.Data.System.Update.CoreUpdateProcess.Complete">
            <summary>
            Complete the process. Fires the complete event.
            </summary>
        </member>
        <member name="M:Companion.Data.System.Update.CoreUpdateProcess.Complete(System.Object)">
            <summary>
            Complete the process. Fires the complete event.
            </summary>
        </member>
        <member name="M:Companion.Data.System.Update.CoreUpdateProcess.Cleanup">
            <summary>
            Cleanup. Fired from Abort() and Complete(). By default does nothing.
            </summary>
        </member>
        <member name="M:Companion.Data.System.Update.CoreUpdateProcess.GetMaxRetries">
            <summary>
            How many times it should retry. By default it does not.
            </summary>
            <returns>Maximum retries</returns>
        </member>
        <member name="M:Companion.Data.System.Update.CoreUpdateProcess.Retry(Companion.Data.System.Update.UpdateStateData)">
            <summary>
            Retry the operation.
            </summary>
            <param name="state">State</param>
        </member>
        <member name="T:Companion.Data.System.Update.IUpdateProcess">
            <summary>
            Handles updating the data files.
            </summary>
        </member>
        <member name="E:Companion.Data.System.Update.IUpdateProcess.LoadingComplete">
            <summary>
            Fired when the process completed.
            </summary>
        </member>
        <member name="E:Companion.Data.System.Update.IUpdateProcess.LoadingAborted">
            <summary>
            Fired when the process is aborted.
            </summary>
        </member>
        <member name="M:Companion.Data.System.Update.IUpdateProcess.Execute(Companion.Data.System.Update.UpdateStateData)">
            <summary>
            Execute the update process and passes any state through.
            </summary>
            <param name="state">current state</param>
        </member>
        <member name="M:Companion.Data.System.Update.IUpdateProcess.Abort">
            <summary>
            Aborts the process.
            </summary>
        </member>
        <member name="M:Companion.Data.System.Update.IUpdateProcess.GetState">
            <summary>
            The update state this process handles.
            </summary>
            <returns>update state</returns>
        </member>
        <member name="T:Companion.Data.System.Update.RetrieveGameSystemIndexProcess">
            <summary>
            Retrieves the index of game systems from the repository url. This reads the json from the repository and creates a <see cref="T:Companion.Data.System.Update.RepositoryIndex"/> from it.
            </summary>
        </member>
        <member name="M:Companion.Data.System.Update.RetrieveGameSystemIndexProcess.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a process to retrieve the index of game systems.
            </summary>
            <param name="url">Repository url</param>
            <param name="async">If true the networking will be asynchronous</param>
        </member>
        <member name="M:Companion.Data.System.Update.RetrieveGameSystemIndexProcess.Execute(Companion.Data.System.Update.UpdateStateData)">
            <inheritdoc/>
        </member>
        <member name="M:Companion.Data.System.Update.RetrieveGameSystemIndexProcess.GetState">
            <inheritdoc/>
        </member>
        <member name="T:Companion.Data.System.Update.RetrieveRepositoryIndexProcess">
            <summary>
            Retrieve the data index from the repository index. This reads the .bsi file (battle scribe index/zipped xml) from the repository index url and create a <see cref="T:Companion.Data.DataIndex"/> from it.
            </summary>
        </member>
        <member name="M:Companion.Data.System.Update.RetrieveRepositoryIndexProcess.#ctor(Companion.Data.System.Update.Repository,System.Boolean)">
            <summary>
            Creates a process to retrieve the data index from the repository index.
            </summary>
            <param name="repository">Repository to get index url from</param>
            <param name="async">If true the networking will be asynchronous</param>
        </member>
        <member name="M:Companion.Data.System.Update.RetrieveRepositoryIndexProcess.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a process to retrieve the data index from the repository index.
            </summary>
            <param name="url">Repository index url</param>
            <param name="async">If true the networking will be asynchronous</param>
        </member>
        <member name="M:Companion.Data.System.Update.RetrieveRepositoryIndexProcess.Execute(Companion.Data.System.Update.UpdateStateData)">
            <inheritdoc/>
        </member>
        <member name="M:Companion.Data.System.Update.RetrieveRepositoryIndexProcess.GetState">
            <inheritdoc/>
        </member>
        <member name="T:Companion.Data.System.Update.UpdateGameSystemProcess">
            <summary>
            Updates a game system from a repository. It will check which files need updating in the data index and download those files only.
            </summary>
        </member>
        <member name="M:Companion.Data.System.Update.UpdateGameSystemProcess.#ctor(Companion.Data.System.Update.Repository,Companion.Data.DataIndex,System.String,System.Boolean)">
            <summary>
            Create a new update system process.
            </summary>
            <param name="repository">Repository to update from</param>
            <param name="dataIndex">Data index retrieved from repository</param>
            <param name="dataPath">File path where the data should reside</param>
            <param name="async">Whether to update async</param>
        </member>
        <member name="M:Companion.Data.System.Update.UpdateGameSystemProcess.Execute(Companion.Data.System.Update.UpdateStateData)">
            <inheritdoc/>
        </member>
        <member name="M:Companion.Data.System.Update.UpdateGameSystemProcess.GetUpdateDataIndices">
            <summary>
            Get a list of the catalogues and game systems from the data index that need updating.
            </summary>
            <returns>List of data index entries that require updating</returns>
        </member>
        <member name="M:Companion.Data.System.Update.UpdateGameSystemProcess.RequiresUpdate(Companion.Data.DataIndexEntry)">
            <summary>
            Checks whether the file exists and if it does whether it has an up to date version. If the file is not readable it will also return true.
            </summary>
            <param name="entry">Entry</param>
            <returns>Returns true if it requires updating</returns>
        </member>
        <member name="M:Companion.Data.System.Update.UpdateGameSystemProcess.GetVersionInfo(System.Byte[],System.String,System.String)">
            <summary>
            Get the version information from the compressed data file on disk.
            </summary>
            <param name="data">Byte data</param>
            <param name="fileExtension">The extension of the compressed file starting with a period</param>
            <param name="elementName">The name of the first element in the xml file that needs to match</param>
            <returns></returns>
        </member>
        <member name="M:Companion.Data.System.Update.UpdateGameSystemProcess.GetState">
            <inheritdoc/>
        </member>
        <member name="T:Companion.Data.System.Update.UpdateStateData">
            <summary>
            Store state during loading
            </summary>
        </member>
        <member name="E:RosterManager.OnRostersLoaded">
            <summary>
            Fired when all rosters are loaded.
            </summary>
        </member>
        <member name="E:RosterManager.OnRostersAdded">
            <summary>
            Fired whenever a roster is added.
            </summary>
        </member>
        <member name="M:RosterManager.AddRoster(System.Byte[])">
            <summary>
            Parse the roster and add it to the roster manager.
            </summary>
            <param name="data">Roster data</param>
        </member>
        <member name="E:SystemManager.OnGameSystemsLoaded">
            <summary>
            Dispatched on the main thread. Source is this. EventArgs is null.
            </summary>
        </member>
        <member name="E:UpdateManager.OnGameSystemIndexReceived">
            <summary>
            Fired when game system index is received. Source is UpdateStateData.
            </summary>
        </member>
        <member name="E:UpdateManager.OnRepositoryIndexReceived">
            <summary>
            Fired when repository index is received. Source is UpdateStateData.
            </summary>
        </member>
        <member name="M:UpdateManager.AddRepository">
            <summary>
            Add repository to the update manager
            </summary>
        </member>
    </members>
</doc>
